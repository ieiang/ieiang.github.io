<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>8种常用排序算法总结</title>
      <link href="/2018/07/10/8%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/10/8%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><blockquote><p>定义：排序前后两个相等的数相对位置不变，则算法稳定。<br>好处：从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。</p></blockquote><h3 id="各排序算法的稳定性"><a href="#各排序算法的稳定性" class="headerlink" title="各排序算法的稳定性"></a>各排序算法的稳定性</h3><p><strong>稳定</strong>：基数排序、冒泡排序、直接插入排序、折半插入排序（二分）、归并排序<br><strong>非稳定</strong>：堆排序、快速排序、希尔排序、直接选择排序</p><hr><h2 id="各排序算法优劣"><a href="#各排序算法优劣" class="headerlink" title="各排序算法优劣"></a>各排序算法优劣</h2><p><img src="https://img-blog.csdn.net/20161015133509349" alt="排序总结比较"></p><p>  <img src="https://pic1.zhimg.com/80/v2-e3a121dea092f9ec2ef727ceab030aad_hd.jpg" alt="各排序算法的优劣"></p><hr><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><blockquote><p>影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点：<br>1．待排序的记录数目n的大小；<br>2．记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；<br>3．关键字的结构及其分布情况；<br>4．对排序稳定性的要求。</p></blockquote><h3 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h3><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><blockquote><p>1、已经有序的小序列的基础上，一次插入一个元素；<br>2、想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置；<br>3、如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面；<br>4、相等元素的前后顺序没有改变；<br>设待排序元素的个数为n.<br>1）当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。<br>快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；<br>堆排序 ： 如果内存空间允许且要求稳定性的，<br>归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。<br>2） 当n较大，内存空间允许，且要求稳定性 =》归并排序<br>3）当n较小，可采用直接插入或直接选择排序。<br>直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。<br>直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序<br>5）一般不使用或不直接使用传统的冒泡排序。<br>6）基数排序<br>它是一种稳定的排序算法，但有一定的局限性：<br>　　1、关键字可分解。<br>　　2、记录的关键字位数较少，如果密集更好<br>　　3、如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。</p></blockquote><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>/** * 插入排序 * &lt;p&gt; * 1. 从第一个元素开始，该元素可以认为已经被排序 * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描 * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置 * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 * 5. 将新元素插入到该位置后 * 6. 重复步骤2~5 * * @param arr 待排序数组 */public static void insertionSort(int[] arr) {    for (int i = 0; i &lt; arr.length - 1; i++) {        for (int j = i + 1; j &gt; 0; j--) {            if (arr[j - 1] &lt;= arr[j]) break;            int temp = arr[j];            arr[j] = arr[j - 1];            arr[j - 1] = temp;            System.out.println(&quot;Sorting:&quot; + Arrays.toString(arr));        }    }}</code></pre><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><blockquote><p><strong>优点</strong>：稳定，快<br><strong>缺点</strong>：比较次数不一定，比较次数越少，插入点后的数据移动越多，特别是当数据总量庞大的时候，但用链表可以解决这个问题</p></blockquote><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><blockquote><p>1、每个位置选择当前元素最小的；<br>2、在一趟选择中，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了；<br>3、举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了；</p></blockquote><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>/** * 选择排序 * * 1. 从待排序序列中，找到关键字最小的元素； * 2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换； * 3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。 *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 * @param arr  待排序数组 */public static void selectionSort(int[] arr){    for(int i = 0; i &lt; arr.length-1; i++){        int min = i;        for(int j = i+1; j &lt; arr.length; j++){    //选出之后待排序中值最小的位置            if(arr[j] &lt; arr[min]){                min = j;            }        }        if(min != i){            int temp = arr[min];      //交换操作            arr[min] = arr[i];            arr[i] = temp;            System.out.println(&quot;Sorting:  &quot; + Arrays.toString(arr));        }    }}</code></pre><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><blockquote><p><strong>优点</strong>：移动数据的次数已知（n-1次）<br><strong>缺点</strong>：比较次数多</p></blockquote><h3 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3.冒泡排序"></a>3.冒泡排序</h3><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><blockquote><p>1、小的元素往前调或者把大的元素往后调；<br>2、比较是相邻的两个元素比较，交换也发生在这两个元素之间；<br>3、稳定排序算法。</p></blockquote><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code> /** * 冒泡排序 * * 1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 * 2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 * 3. 针对所有的元素重复以上的步骤，除了最后一个。 * 4. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。 * @param arr  待排序数组 */public static void bubbleSort(int[] arr){    for (int i = arr.length; i &gt; 0; i--) {      //外层循环移动游标        for(int j = 0; j &lt; i &amp;&amp; (j+1) &lt; i; j++){    //内层循环遍历游标及之后(或之前)的元素            if(arr[j] &gt; arr[j+1]){                int temp = arr[j];                arr[j] = arr[j+1];                arr[j+1] = temp;                System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));            }        }    }}</code></pre><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><blockquote><p><strong>优点</strong>：稳定<br><strong>缺点</strong>：慢，每次只能移动相邻两个数据</p></blockquote><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h3><h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><blockquote><p>1、两个方向，左边的i下标一直往右走，当a[i] &lt;=<br>a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]；<br>2、如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j；<br>3、交换a[j]和a[center_index]，完成一趟快速排序；<br>4、在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱；<br>5、不稳定发生在中枢元素和a[j] 交换的时刻；<br>6、不稳定的排序算法。</p></blockquote><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code> /** * 快速排序（递归） * * 1. 从数列中挑出一个元素，称为&quot;基准&quot;（pivot）。 * 2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 * 3. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 * @param arr   待排序数组 * @param low   左边界 * @param high  右边界 */public static void quickSort(int[] arr, int low, int high){    if(arr.length &lt;= 0) return;    if(low &gt;= high) return;    int left = low;    int right = high;    int temp = arr[left];   //挖坑1：保存基准的值    while (left &lt; right){        while(left &lt; right &amp;&amp; arr[right] &gt;= temp){  //坑2：从后向前找到比基准小的元素，插入到基准位置坑1中            right--;        }        arr[left] = arr[right];        while(left &lt; right &amp;&amp; arr[left] &lt;= temp){   //坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中            left++;        }        arr[right] = arr[left];    }    arr[left] = temp;   //基准值填补到坑3中，准备分治递归快排    System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));    quickSort(arr, low, left-1);    quickSort(arr, left+1, high);}</code></pre><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><blockquote><p><strong>优点</strong>：极快，数据移动少.<br><strong>缺点</strong>：不稳定</p></blockquote><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h3><h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><blockquote><p>1、把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的短序列合并成一个有序的长序列，不断合并直到原序列全部排好序；<br>2、合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性；<br>3、稳定排序算法。</p></blockquote><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>/** * 归并排序（递归） * * 1. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素； * 2. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素； * 3. 重复步骤2，直到所有元素排序完毕。 * @param arr     待排序数组 */public static int[] mergingSort(int[] arr){    if(arr.length &lt;= 1) return arr;    int num = arr.length &gt;&gt; 1;    int[] leftArr = Arrays.copyOfRange(arr, 0, num);    int[] rightArr = Arrays.copyOfRange(arr, num, arr.length);    System.out.println(&quot;split two array: &quot; + Arrays.toString(leftArr) + &quot; And &quot; + Arrays.toString(rightArr));    return mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr));      //不断拆分为最小单元，再排序合并}private static int[] mergeTwoArray(int[] arr1, int[] arr2){    int i = 0, j = 0, k = 0;    int[] result = new int[arr1.length + arr2.length];  //申请额外的空间存储合并之后的数组    while(i &lt; arr1.length &amp;&amp; j &lt; arr2.length){      //选取两个序列中的较小值放入新数组        if(arr1[i] &lt;= arr2[j]){            result[k++] = arr1[i++];        }else{            result[k++] = arr2[j++];        }    }    while(i &lt; arr1.length){     //序列1中多余的元素移入新数组        result[k++] = arr1[i++];    }    while(j &lt; arr2.length){     //序列2中多余的元素移入新数组        result[k++] = arr2[j++];    }    System.out.println(&quot;Merging: &quot; + Arrays.toString(result));    return result;}</code></pre><h4 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h4><blockquote><p>归并排序是一种非就地排序，将需要与待排序序列一样多的辅助空间。在使用它对两个己有序的序列归并，将有无比的优势。其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlog2n)。对数据的有序性不敏感。若数据节点数据量大，那将不适合。但可改造成索引操作，效果将非常出色</p></blockquote><h3 id="6-希尔排序"><a href="#6-希尔排序" class="headerlink" title="6.希尔排序"></a>6.希尔排序</h3><h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><blockquote><p>1、按照不同步长对元素进行插入排序；<br>2、当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；<br>3、当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高；<br>4、所以，希尔排序的时间复杂度会比o(n^2)好一些<br>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱；<br>5、不稳定的排序算法。</p></blockquote><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code> /** * 希尔排序 * * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（一般初次取数组半长，之后每次再减半，直到增量为1） * 2. 按增量序列个数k，对序列进行k 趟排序； * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。 *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 * @param arr  待排序数组 */public static void shellSort(int[] arr){    int gap = arr.length / 2;    for (; gap &gt; 0; gap /= 2) {      //不断缩小gap，直到1为止        for (int j = 0; (j+gap) &lt; arr.length; j++){     //使用当前gap进行组内插入排序            for(int k = 0; (k+gap)&lt; arr.length; k += gap){                if(arr[k] &gt; arr[k+gap]) {                    int temp = arr[k+gap];      //交换操作                    arr[k+gap] = arr[k];                    arr[k] = temp;                    System.out.println(&quot;    Sorting:  &quot; + Arrays.toString(arr));                }            }        }    }}</code></pre><h4 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h4><blockquote><p><strong>优点</strong>：快，数据移动少<br><strong>缺点</strong>：不稳定，d的取值是多少，应取多少个不同的值，都无法确切知道，只能凭经验来取</p></blockquote><h3 id="7-基数排序"><a href="#7-基数排序" class="headerlink" title="7.基数排序"></a>7.基数排序</h3><h4 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h4><blockquote><p>1、按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位；<br>2、有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前；<br>3、用于整数；<br>4、需要较多的存储空间；<br>5、基于分别排序，分别收集；<br>6、稳定排序算法。</p></blockquote><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>  /** * 基数排序（LSD 从低位开始） * * 基数排序适用于： *  (1)数据范围较小，建议在小于1000 *  (2)每个数值都要大于等于0 * * 1. 取得数组中的最大数，并取得位数； * 2. arr为原始数组，从最低位开始取每个位组成radix数组； * 3. 对radix进行计数排序（利用计数排序适用于小范围数的特点） * @param arr     待排序数组 */public static void radixSort(int[] arr){    if(arr.length &lt;= 1) return;    //取得数组中的最大数，并取得位数    int max = 0;    for(int i = 0; i &lt; arr.length; i++){        if(max &lt; arr[i]){            max = arr[i];        }    }    int maxDigit = 1;    while(max / 10 &gt; 0){        maxDigit++;        max = max / 10;    }    System.out.println(&quot;maxDigit: &quot; + maxDigit);    //申请一个桶空间    int[][] buckets = new int[10][arr.length];    int base = 10;    //从低位到高位，对每一位遍历，将所有元素分配到桶中    for(int i = 0; i &lt; maxDigit; i++){        int[] bktLen = new int[10];        //存储各个桶中存储元素的数量        //分配：将所有元素分配到桶中        for(int j = 0; j &lt; arr.length; j++){            int whichBucket = (arr[j] % base) / (base / 10);            buckets[whichBucket][bktLen[whichBucket]] = arr[j];            bktLen[whichBucket]++;        }        //收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞        int k = 0;        for(int b = 0; b &lt; buckets.length; b++){            for(int p = 0; p &lt; bktLen[b]; p++){                arr[k++] = buckets[b][p];            }        }        System.out.println(&quot;Sorting: &quot; + Arrays.toString(arr));        base *= 10;    }}</code></pre><h4 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h4><blockquote><p><strong>优点</strong>：稳定</p></blockquote><h3 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="8.堆排序"></a>8.堆排序</h3><h4 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h4><blockquote><p>1、是选择排序的一种；<br>2、堆的结构是节点i的孩子为2<em>i和2</em>i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点，是完全二叉树；<br>3、在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了；<br>4、不稳定的排序算法。</p></blockquote><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>  /** * 堆排序 * * 1. 先将初始序列K[1..n]建成一个大顶堆, 那么此时第一个元素K1最大, 此堆为初始的无序区. * 2. 再将关键字最大的记录K1 (即堆顶, 第一个元素)和无序区的最后一个记录 Kn 交换, 由此得到新的无序区K[1..n−1]和有序区K[n], 且满足K[1..n−1].keys⩽K[n].key * 3. 交换K1 和 Kn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止. * @param arr  待排序数组 */public static void heapSort(int[] arr){    for(int i = arr.length; i &gt; 0; i--){        max_heapify(arr, i);        int temp = arr[0];      //堆顶元素(第一个元素)与Kn交换        arr[0] = arr[i-1];        arr[i-1] = temp;    }}private static void max_heapify(int[] arr, int limit){    if(arr.length &lt;= 0 || arr.length &lt; limit) return;    int parentIdx = limit / 2;    for(; parentIdx &gt;= 0; parentIdx--){        if(parentIdx * 2 &gt;= limit){            continue;        }        int left = parentIdx * 2;       //左子节点位置        int right = (left + 1) &gt;= limit ? left : (left + 1);    //右子节点位置，如果没有右节点，默认为左节点位置        int maxChildId = arr[left] &gt;= arr[right] ? left : right;        if(arr[maxChildId] &gt; arr[parentIdx]){   //交换父节点与左右子节点中的最大值            int temp = arr[parentIdx];            arr[parentIdx] = arr[maxChildId];            arr[maxChildId] = temp;        }    }    System.out.println(&quot;Max_Heapify: &quot; + Arrays.toString(arr));}</code></pre><h4 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h4><blockquote><p>由于它在直接选择排序的基础上利用了比较结果形成。效率提高很大。它完成排序的总比较次数为O(nlog2n)。它是对数据的有序性不敏感的一种算法。但堆排序将需要做两个步骤：－是建堆，二是排序（调整堆）。所以一般在小规模的序列中不合适，但对于较大的序列，将表现出优越的性能。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo+GitPage搭建个人博客</title>
      <link href="/2018/07/10/Hexo-GitPage%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/07/10/Hexo-GitPage%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h3 id="1-注册Github账号"><a href="#1-注册Github账号" class="headerlink" title="1. 注册Github账号"></a>1. 注册Github账号</h3><p>创建一个仓库命名为xxx.github.io（xxx为你的用户名）</p><h3 id="2-配置SSH-Key"><a href="#2-配置SSH-Key" class="headerlink" title="2. 配置SSH Key"></a>2. 配置SSH Key</h3><pre><code>git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot;ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code></pre><p>接着回车就行，然后打开<code>C:\Users\TT\.ssh\id_rsa.pub</code>文件，复制里面内容<br>登录自己Github，点击个人头像找到<code>settings</code>,点进去找到<code>SSH and GPG keys</code>,然后新建SSHKey，将上面复制的内容拷贝到<code>key</code>里面<br>完成后进行测试</p><pre><code>ssh -T git@github.com</code></pre><p>如果看到</p><blockquote><p>The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.<br>    RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.<br>    Are you sure you want to continue connecting (yes/no)?</p></blockquote><p>选则yes</p><blockquote><p>hi xxx!You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>如果xxx是你的用户名，就说明配置成功</p><h3 id="3-安装配置Hexo"><a href="#3-安装配置Hexo" class="headerlink" title="3. 安装配置Hexo"></a>3. 安装配置Hexo</h3><p>需要安装Node服务，如果没有安装去官网下载安装<br>创建一个文件夹，用作博客目录，下面命令都在此目录下运行</p><pre><code>npm install hexo-cli -g #安装hexo脚手架hexo init #初始化hexonpm install hexo-deployer-git --save #安装hexo发布到git工具</code></pre><p>上面安装结束，可以执行命令看下效果</p><pre><code>hexo ghexo s</code></pre><p>访问<code>localhost:4000</code>查看，初始界面不是很美观，可以去hexo网站选择自己喜欢的主题下载<br>我选的<code>freemind.386</code>,去github找到该主题地址，然后git克隆到本地themes文件夹下<br>打开博客文件夹中<code>_config.yaml</code>文件,找到<code>theme</code>选项改为<code>theme: hexo-theme-freemind.386</code>开启主题</p><p>创建tags、categories、about、archives页面</p><pre><code>hexo new page tagshexo new page categorieshexo new page abouthexo new page archives</code></pre><p><strong>创建好页面后，标签和分类出不来，需要配置</strong><br>打开<code>source\tags\index.md</code>,<code>---</code>中内容改为</p><blockquote><p>title: tags<br>date: 2018-07-10 05:01:18<br>type: “tags”<br>layout: “tags”<br>comments: false</p></blockquote><p><code>categories</code>类似</p><p>新建博客</p><pre><code>hexo new &quot;博客名&quot;</code></pre><p>为该博文添加标签和分类，打开<code>source\_posts</code>下的博客md文件，添加·<code>tags</code>、<code>categories</code></p><h3 id="4-发布到GitHub"><a href="#4-发布到GitHub" class="headerlink" title="4. 发布到GitHub"></a>4. 发布到GitHub</h3><p>打开<code>_config.yaml</code>文件，修改</p><pre><code>deploy:    type: git    repo: git@github.com:xxx/xxx.github.io.git # 上面创建的那个xxx.github.io仓库，找到它的ssh路径    branch: master</code></pre><p>执行命令</p><pre><code>hexo d -g</code></pre>]]></content>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
